import SwiftUI
import Charts // iOS 16‰ª•‰∏ä„ÅßÂà©Áî®ÂèØËÉΩ

struct MBTIStatsView: View {
    @EnvironmentObject var viewModel: MainViewModel
    @State private var selectedMBTI: String? = nil
    @State private var showMBTISelector = false
    @State private var selectedMetric: MetricType = .studyTime
    @State private var isLoading = true
    
    enum MetricType: String, CaseIterable {
        case studyTime = "Â≠¶ÁøíÊôÇÈñì"
        case userCount = "„É¶„Éº„Ç∂„ÉºÊï∞"
        case averageTime = "Âπ≥ÂùáÊôÇÈñì"
    }
    
    var body: some View {
        ZStack {
            MinimalDarkBackgroundView()
            
            VStack(spacing: 0) {
                // „Éò„ÉÉ„ÉÄ„Éº
                headerSection
                
                if isLoading {
                    loadingSection
                } else if viewModel.mbtiStatistics.isEmpty {
                    emptyStateSection
                } else {
                    ScrollView {
                        VStack(spacing: 25) {
                            // Ëá™ÂàÜ„ÅÆMBTIÊÉÖÂ†±
                            if let myMBTI = viewModel.user?.mbtiType {
                                myMBTISection(mbti: myMBTI)
                            } else {
                                mbtiSetupSection
                            }
                            
                            // „É°„Éà„É™„ÇØ„ÇπÈÅ∏Êäû
                            metricSelectorSection
                            
                            // ÂÜÜ„Ç∞„É©„Éï„Çª„ÇØ„Ç∑„Éß„É≥
                            chartSection
                            
                            // Ë©≥Á¥∞Áµ±Ë®à
                            detailsSection
                            
                            // „É©„É≥„Ç≠„É≥„Ç∞
                            rankingSection
                        }
                        .padding()
                    }
                }
            }
        }
        .onAppear {
            loadStatistics()
        }
        .sheet(isPresented: $showMBTISelector) {
            MBTISelectionView(selectedMBTI: $selectedMBTI)
                .environmentObject(viewModel)
        }
    }
    
    // MARK: - „Éò„ÉÉ„ÉÄ„Éº„Çª„ÇØ„Ç∑„Éß„É≥
    private var headerSection: some View {
        Text("MBTIÂà• Â≠¶ÁøíÁµ±Ë®à")
            .font(.title2)
            .fontWeight(.bold)
            .foregroundColor(.white)
            .padding(.top)
    }
    
    // MARK: - „É≠„Éº„Éá„Ç£„É≥„Ç∞„Çª„ÇØ„Ç∑„Éß„É≥
    private var loadingSection: some View {
        VStack(spacing: 20) {
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                .scaleEffect(1.5)
            
            Text("Áµ±Ë®à„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø‰∏≠...")
                .font(.headline)
                .foregroundColor(.white.opacity(0.7))
        }
        .frame(maxHeight: .infinity)
    }
    
    // MARK: - Á©∫Áä∂ÊÖã„Çª„ÇØ„Ç∑„Éß„É≥
    private var emptyStateSection: some View {
        VStack(spacing: 20) {
            Image(systemName: "chart.pie")
                .font(.system(size: 60))
                .foregroundColor(.white.opacity(0.3))
            
            Text("Áµ±Ë®à„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
                .font(.title3)
                .foregroundColor(.white.opacity(0.7))
            
            Text("„Åæ„Å†ÂçÅÂàÜ„Å™„Éá„Éº„Çø„ÅåËìÑÁ©ç„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì")
                .font(.caption)
                .foregroundColor(.white.opacity(0.5))
        }
        .frame(maxHeight: .infinity)
    }
    
    // MARK: - Ëá™ÂàÜ„ÅÆMBTI„Çª„ÇØ„Ç∑„Éß„É≥
    private func myMBTISection(mbti: String) -> some View {
        let stats = viewModel.mbtiStatistics[mbti]
        
        return VStack(spacing: 15) {
            HStack {
                Text("„ÅÇ„Å™„Åü„ÅÆMBTI")
                    .font(.headline)
                    .foregroundColor(.white.opacity(0.7))
                
                Spacer()
                
                Button("Â§âÊõ¥") {
                    showMBTISelector = true
                }
                .font(.caption)
                .foregroundColor(.blue)
            }
            
            HStack(spacing: 20) {
                // MBTIË°®Á§∫
                ZStack {
                    RoundedRectangle(cornerRadius: 15)
                        .fill(
                            LinearGradient(
                                colors: [Color.purple.opacity(0.3), Color.blue.opacity(0.2)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 80, height: 80)
                    
                    Text(mbti)
                        .font(.system(size: 24, weight: .bold))
                        .foregroundColor(.white)
                }
                
                // Áµ±Ë®àÊÉÖÂ†±
                VStack(alignment: .leading, spacing: 8) {
                    if let stats = stats {
                        // üîß ‰øÆÊ≠£: StatRow„ÇíMBTIStatRow„Å´ÂêçÂâçÂ§âÊõ¥„Åó„Å¶„Ç≥„É≥„Éï„É™„ÇØ„ÉàÂõûÈÅø
                        MBTIStatRow(
                            title: "Á∑èÂ≠¶ÁøíÊôÇÈñì",
                            value: formatTime(stats.totalTime),
                            color: .green
                        )
                        MBTIStatRow(
                            title: "Âπ≥ÂùáÊôÇÈñì/Êó•",
                            value: formatTime(stats.avgTime),
                            color: .blue
                        )
                        MBTIStatRow(
                            title: "Âêå„Çø„Ç§„Éó„É¶„Éº„Ç∂„Éº",
                            value: "\(stats.userCount)‰∫∫",
                            color: .purple
                        )
                    } else {
                        Text("„Éá„Éº„ÇøÂèéÈõÜ‰∏≠...")
                            .font(.caption)
                            .foregroundColor(.white.opacity(0.5))
                    }
                }
                
                Spacer()
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 20)
                .fill(Color.white.opacity(0.05))
                .overlay(
                    RoundedRectangle(cornerRadius: 20)
                        .stroke(Color.purple.opacity(0.3), lineWidth: 1)
                )
        )
    }
    
    // MARK: - MBTIË®≠ÂÆö„Çª„ÇØ„Ç∑„Éß„É≥
    private var mbtiSetupSection: some View {
        Button(action: { showMBTISelector = true }) {
            VStack(spacing: 15) {
                Image(systemName: "brain.head.profile")
                    .font(.system(size: 40))
                    .foregroundColor(.purple)
                
                Text("MBTI„Çø„Ç§„Éó„ÇíË®≠ÂÆö")
                    .font(.headline)
                    .foregroundColor(.white)
                
                Text("Áµ±Ë®àÊÉÖÂ†±„ÇíË°®Á§∫„Åô„Çã„Åü„ÇÅ„ÄÅ„ÅÇ„Å™„Åü„ÅÆMBTI„Çø„Ç§„Éó„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.7))
                    .multilineTextAlignment(.center)
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color.purple.opacity(0.1))
                    .overlay(
                        RoundedRectangle(cornerRadius: 20)
                            .stroke(Color.purple.opacity(0.3), lineWidth: 1)
                    )
            )
        }
    }
    
    // MARK: - „É°„Éà„É™„ÇØ„ÇπÈÅ∏Êäû„Çª„ÇØ„Ç∑„Éß„É≥
    private var metricSelectorSection: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Ë°®Á§∫È†ÖÁõÆ")
                .font(.headline)
                .foregroundColor(.white.opacity(0.7))
            
            HStack(spacing: 10) {
                ForEach(MetricType.allCases, id: \.self) { metric in
                    Button(action: {
                        withAnimation(.spring()) {
                            selectedMetric = metric
                        }
                    }) {
                        Text(metric.rawValue)
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundColor(selectedMetric == metric ? .white : .white.opacity(0.6))
                            .padding(.horizontal, 12)
                            .padding(.vertical, 8)
                            .background(
                                Capsule()
                                    .fill(selectedMetric == metric ? Color.blue.opacity(0.3) : Color.white.opacity(0.1))
                                    .overlay(
                                        Capsule()
                                            .stroke(
                                                selectedMetric == metric ? Color.blue : Color.white.opacity(0.2),
                                                lineWidth: 1
                                            )
                                    )
                            )
                    }
                }
            }
        }
    }
    
    // MARK: - „ÉÅ„É£„Éº„Éà„Çª„ÇØ„Ç∑„Éß„É≥
    private var chartSection: some View {
        VStack(alignment: .leading, spacing: 15) {
            Text("MBTIÂàÜÂ∏É")
                .font(.headline)
                .foregroundColor(.white.opacity(0.7))
            
            if #available(iOS 16.0, *) {
                MBTIPieChart(
                    statistics: viewModel.mbtiStatistics,
                    metric: selectedMetric
                )
                .frame(height: 300)
            } else {
                // iOS 16Êú™Ê∫Ä„ÅÆÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                MBTILegacyChart(
                    statistics: viewModel.mbtiStatistics,
                    metric: selectedMetric
                )
                .frame(height: 300)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 20)
                .fill(Color.white.opacity(0.05))
                .overlay(
                    RoundedRectangle(cornerRadius: 20)
                        .stroke(Color.white.opacity(0.1), lineWidth: 1)
                )
        )
    }
    
    // MARK: - Ë©≥Á¥∞„Çª„ÇØ„Ç∑„Éß„É≥
    private var detailsSection: some View {
        VStack(alignment: .leading, spacing: 15) {
            Text("Ë©≥Á¥∞Áµ±Ë®à")
                .font(.headline)
                .foregroundColor(.white.opacity(0.7))
            
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 15) {
                MBTIStatCard(
                    title: "Á∑è„É¶„Éº„Ç∂„ÉºÊï∞",
                    value: "\(getTotalUsers())‰∫∫",
                    icon: "person.3.fill",
                    color: .blue
                )
                
                MBTIStatCard(
                    title: "Á∑èÂ≠¶ÁøíÊôÇÈñì",
                    value: formatTime(getTotalStudyTime()),
                    icon: "clock.fill",
                    color: .green
                )
                
                MBTIStatCard(
                    title: "Âπ≥ÂùáÂ≠¶ÁøíÊôÇÈñì",
                    value: formatTime(getAverageStudyTime()),
                    icon: "chart.bar.fill",
                    color: .orange
                )
                
                MBTIStatCard(
                    title: "ÊúÄ„ÇÇÂ§ö„ÅÑ„Çø„Ç§„Éó",
                    value: getMostPopularMBTI(),
                    icon: "crown.fill",
                    color: .purple
                )
            }
        }
    }
    
    // MARK: - „É©„É≥„Ç≠„É≥„Ç∞„Çª„ÇØ„Ç∑„Éß„É≥
    private var rankingSection: some View {
        VStack(alignment: .leading, spacing: 15) {
            Text("Â≠¶ÁøíÊôÇÈñì„É©„É≥„Ç≠„É≥„Ç∞")
                .font(.headline)
                .foregroundColor(.white.opacity(0.7))
            
            VStack(spacing: 10) {
                ForEach(getSortedMBTIStats(), id: \.mbtiType) { stat in
                    MBTIRankingRow(
                        mbtiStat: stat,
                        rank: getRank(for: stat),
                        isMyType: stat.mbtiType == viewModel.user?.mbtiType
                    )
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 20)
                .fill(Color.white.opacity(0.05))
                .overlay(
                    RoundedRectangle(cornerRadius: 20)
                        .stroke(Color.white.opacity(0.1), lineWidth: 1)
                )
        )
    }
    
    // MARK: - Private Methods
    private func loadStatistics() {
        Task {
            isLoading = true
            await viewModel.loadMBTIStatistics()
            await MainActor.run {
                isLoading = false
            }
        }
    }
    
    private func formatTime(_ seconds: Double) -> String {
        let hours = Int(seconds) / 3600
        let minutes = Int(seconds) % 3600 / 60
        
        if hours > 24 {
            let days = hours / 24
            let remainingHours = hours % 24
            return "\(days)Êó•\(remainingHours)ÊôÇÈñì"
        } else if hours > 0 {
            return "\(hours)ÊôÇÈñì\(minutes)ÂàÜ"
        } else {
            return "\(minutes)ÂàÜ"
        }
    }
    
    private func getTotalUsers() -> Int {
        viewModel.mbtiStatistics.values.reduce(0) { $0 + $1.userCount }
    }
    
    private func getTotalStudyTime() -> Double {
        viewModel.mbtiStatistics.values.reduce(0) { $0 + $1.totalTime }
    }
    
    private func getAverageStudyTime() -> Double {
        let totalUsers = getTotalUsers()
        guard totalUsers > 0 else { return 0 }
        return getTotalStudyTime() / Double(totalUsers)
    }
    
    private func getMostPopularMBTI() -> String {
        guard let mostPopular = viewModel.mbtiStatistics.max(by: { $0.value.userCount < $1.value.userCount }) else {
            return "N/A"
        }
        return mostPopular.key
    }
    
    private func getSortedMBTIStats() -> [MBTIStatData] {
        viewModel.mbtiStatistics.values.sorted { $0.totalTime > $1.totalTime }
    }
    
    private func getRank(for stat: MBTIStatData) -> Int {
        let sorted = getSortedMBTIStats()
        return (sorted.firstIndex { $0.mbtiType == stat.mbtiType } ?? 0) + 1
    }
}

// MARK: - iOS 16‰ª•‰∏äÁî®„ÅÆÂÜÜ„Ç∞„É©„Éï
@available(iOS 16.0, *)
struct MBTIPieChart: View {
    let statistics: [String: MBTIStatData]
    let metric: MBTIStatsView.MetricType
    
    private var chartData: [(String, Double, Color)] {
        statistics.compactMap { key, stat in
            let value: Double
            switch metric {
            case .studyTime:
                value = stat.totalTime
            case .userCount:
                value = Double(stat.userCount)
            case .averageTime:
                value = stat.avgTime
            }
            
            let color = getMBTIColor(key)
            return (key, value, color)
        }
        .filter { $0.1 > 0 }
        .sorted { $0.1 > $1.1 }
    }
    
    var body: some View {
        VStack {
            Chart(chartData, id: \.0) { item in
                SectorMark(
                    angle: .value("Value", item.1),
                    innerRadius: .ratio(0.4),
                    angularInset: 2
                )
                .foregroundStyle(item.2.gradient)
                .cornerRadius(8)
            }
            .chartBackground { _ in
                // ‰∏≠Â§Æ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà
                VStack {
                    Text(metric.rawValue)
                        .font(.headline)
                        .foregroundColor(.white)
                    
                    Text("ÂêàË®à: \(formatTotalValue())")
                        .font(.caption)
                        .foregroundColor(.white.opacity(0.7))
                }
            }
            
            // Âá°‰æã
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible()),
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 8) {
                ForEach(chartData, id: \.0) { item in
                    HStack(spacing: 4) {
                        Circle()
                            .fill(item.2)
                            .frame(width: 8, height: 8)
                        
                        Text(item.0)
                            .font(.caption2)
                            .foregroundColor(.white.opacity(0.8))
                    }
                }
            }
        }
    }
    
    private func formatTotalValue() -> String {
        let total = chartData.reduce(0) { $0 + $1.1 }
        switch metric {
        case .studyTime, .averageTime:
            let hours = Int(total) / 3600
            return "\(hours)ÊôÇÈñì"
        case .userCount:
            return "\(Int(total))‰∫∫"
        }
    }
    
    private func getMBTIColor(_ mbti: String) -> Color {
        // MBTI„Çø„Ç§„Éó„Å´Âü∫„Å•„ÅÑ„ÅüËâ≤ÂàÜ„Åë
        switch mbti.prefix(2) {
        case "NT": return .blue
        case "NF": return .green
        case "ST": return .orange
        case "SF": return .purple
        default: return .gray
        }
    }
}

// MARK: - iOS 16Êú™Ê∫ÄÁî®„ÅÆ„É¨„Ç¨„Ç∑„Éº„ÉÅ„É£„Éº„Éà
struct MBTILegacyChart: View {
    let statistics: [String: MBTIStatData]
    let metric: MBTIStatsView.MetricType
    
    private var chartData: [(String, Double, Color)] {
        statistics.compactMap { key, stat in
            let value: Double
            switch metric {
            case .studyTime:
                value = stat.totalTime
            case .userCount:
                value = Double(stat.userCount)
            case .averageTime:
                value = stat.avgTime
            }
            
            let color = getMBTIColor(key)
            return (key, value, color)
        }
        .filter { $0.1 > 0 }
        .sorted { $0.1 > $1.1 }
    }
    
    var body: some View {
        VStack {
            // Á∞°ÊòìÁöÑ„Å™Ê£í„Ç∞„É©„Éï
            VStack(alignment: .leading, spacing: 8) {
                ForEach(chartData.prefix(8), id: \.0) { item in
                    HStack {
                        Text(item.0)
                            .font(.caption)
                            .foregroundColor(.white)
                            .frame(width: 50, alignment: .leading)
                        
                        GeometryReader { geometry in
                            HStack {
                                RoundedRectangle(cornerRadius: 4)
                                    .fill(item.2.gradient)
                                    .frame(width: geometry.size.width * getPercentage(for: item.1))
                                    .animation(.spring(), value: item.1)
                                
                                Spacer()
                            }
                        }
                        .frame(height: 20)
                        
                        Text(formatValue(item.1))
                            .font(.caption2)
                            .foregroundColor(.white.opacity(0.7))
                            .frame(width: 60, alignment: .trailing)
                    }
                }
            }
            
            Text("‚Äª iOS 16‰ª•‰∏ä„ÅßÂÜÜ„Ç∞„É©„ÉïË°®Á§∫ÂèØËÉΩ")
                .font(.caption2)
                .foregroundColor(.white.opacity(0.5))
                .padding(.top)
        }
    }
    
    private func getPercentage(for value: Double) -> CGFloat {
        let maxValue = chartData.max { $0.1 < $1.1 }?.1 ?? 1
        return CGFloat(value / maxValue)
    }
    
    private func formatValue(_ value: Double) -> String {
        switch metric {
        case .studyTime, .averageTime:
            let hours = Int(value) / 3600
            return "\(hours)h"
        case .userCount:
            return "\(Int(value))‰∫∫"
        }
    }
    
    private func getMBTIColor(_ mbti: String) -> Color {
        switch mbti.prefix(2) {
        case "NT": return .blue
        case "NF": return .green
        case "ST": return .orange
        case "SF": return .purple
        default: return .gray
        }
    }
}

// MARK: - Áµ±Ë®à„Ç´„Éº„Éâ
struct  MBTIStatCard: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(color)
            
            Text(value)
                .font(.headline)
                .fontWeight(.bold)
                .foregroundColor(.white)
            
            Text(title)
                .font(.caption)
                .foregroundColor(.white.opacity(0.7))
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 15)
                .fill(Color.white.opacity(0.05))
                .overlay(
                    RoundedRectangle(cornerRadius: 15)
                        .stroke(color.opacity(0.3), lineWidth: 1)
                )
        )
    }
}

// MARK: - MBTI„É©„É≥„Ç≠„É≥„Ç∞Ë°å
struct MBTIRankingRow: View {
    let mbtiStat: MBTIStatData
    let rank: Int
    let isMyType: Bool
    
    private var rankColor: Color {
        switch rank {
        case 1: return .yellow
        case 2: return Color(white: 0.7)
        case 3: return Color(red: 0.8, green: 0.5, blue: 0.2)
        default: return .white.opacity(0.7)
        }
    }
    
    var body: some View {
        HStack {
            // „É©„É≥„ÇØ
            Text("#\(rank)")
                .font(.system(size: 14, weight: .bold))
                .foregroundColor(rankColor)
                .frame(width: 30)
            
            // MBTI
            Text(mbtiStat.mbtiType)
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(isMyType ? .yellow : .white)
                .frame(width: 50)
            
            VStack(alignment: .leading, spacing: 2) {
                HStack {
                    Text("Á∑èÂ≠¶ÁøíÊôÇÈñì:")
                        .font(.caption)
                        .foregroundColor(.white.opacity(0.6))
                    
                    Text(formatTime(mbtiStat.totalTime))
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(.green)
                }
                
                HStack {
                    Text("„É¶„Éº„Ç∂„ÉºÊï∞:")
                        .font(.caption)
                        .foregroundColor(.white.opacity(0.6))
                    
                    Text("\(mbtiStat.userCount)‰∫∫")
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(.blue)
                }
            }
            
            Spacer()
            
            VStack(alignment: .trailing, spacing: 2) {
                Text("Âπ≥Âùá")
                    .font(.caption2)
                    .foregroundColor(.white.opacity(0.5))
                
                Text(formatTime(mbtiStat.avgTime))
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(.purple)
            }
        }
        .padding(.vertical, 8)
        .padding(.horizontal, 12)
        .background(
            RoundedRectangle(cornerRadius: 10)
                .fill(isMyType ? Color.yellow.opacity(0.1) : Color.white.opacity(0.05))
        )
    }
    
    private func formatTime(_ seconds: Double) -> String {
        let hours = Int(seconds) / 3600
        if hours > 24 {
            let days = hours / 24
            return "\(days)Êó•"
        } else if hours > 0 {
            return "\(hours)ÊôÇÈñì"
        } else {
            let minutes = Int(seconds) / 60
            return "\(minutes)ÂàÜ"
        }
    }
}

// MARK: - üîß ‰øÆÊ≠£ÔºöStatRow„ÇíMBTIStatRow„Å´ÂêçÂâçÂ§âÊõ¥„Åó„Å¶„Ç≥„É≥„Éï„É™„ÇØ„ÉàÂõûÈÅø
struct MBTIStatRow: View {
    let title: String
    let value: String
    let color: Color
    
    var body: some View {
        HStack {
            Text(title)
                .font(.caption)
                .foregroundColor(.white.opacity(0.7))
            
            Spacer()
            
            Text(value)
                .font(.caption)
                .fontWeight(.semibold)
                .foregroundColor(color)
        }
    }
}
